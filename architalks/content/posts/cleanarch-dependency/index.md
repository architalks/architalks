---
title: "Зависимости, интерфейсы и поток управления"
date: 2022-10-11T13:39:45+03:00
draft: false
tags:
- чистая архитектура
- clean architecture
- dependency
---


## Принцип зависимости

__Основной принцип чистой архитектуры - верхний уровень не зависит от нижнего.__ Нижний зависит от верхнего.
Этот принцип должен буквально отражаться в коде: в пакетах нижнего уровня должен быть `import` пакетов верхнего уровня, но не наоборот.

Вспомним, что верхним называется уровень бизнес логики, а все взаимодействие с внешним миром - нижним.

![Dependency](dependency.png#center)

На картинке, сверху отображены пакеты верхнего уровня с бизнес-логикой: `Domain`, включающий `Entity` и `UseCase`. Прием запроса по `http` и сохранение/получение в/из БД - это нижний уровень.
Иногда ошибочно уровни рассматривают по потоку управления (синяя стрелка): от `http` к `db`, считая, что `http` - верхний уровень.

**Правильно: верхний уровень - всегда бизнес-логика.**


## Зависимость vs поток управления

В нашем случае, при получении запроса, поток управления проходит так:

`http → Presenter → Domain → Repository → db`

А по правилу зависимости должно быть:

`http → Presenter → Domain ← Repository ← db`

В направлении `Domain - db` получаем противоречие. 
Разрешается оно обратной зависимостью (принцип Dependency Inversion в SOLID). Проще говоря, объявлением интерфейса. 
В `Domain` объявляется интерфейс, а в `Repository` реализуется.  `UseCase` выполняет обращение к `Repository`, вызывая метод интерфейса. 
Т.о. в коде нижнего уровня (`Repository`) размещается `import` пакета `Domain` с интерфейсом. А в Domain `import` не нужен.

## Границы

Объявление интерфейса означает проведение границы между уровнями. Общение мимо интерфейсов сразу сигналит нам о несанкционированном пересечении границы. Интерейс выполняет роль контракта.

**Определяем контракт и следим за его выполнением.**

На практике получаем: 
- возможность безболезненной замены реализации нижнего уровня без изменения верхнего
- простую тестируемость `UseCase` без реальных обращений к нижнему уровню (БД, файловой системе и пр.)

Есть еще интересная возможность, которую часто упускают или не придают ей значение. Разработку можно начинать с бизнес-логики, именно с того, что требуется бизнесу. Потом уже можем прикрутить БД, сетевое взаимодействие и пр. Такой подход, конечно, невозможен без активного покрытия кода unit-тестами.


## Не совсем P.S.

Забыли про еще одну зависимость: `Domain - Presenter`. Здесь все просто: `import Domain` располагается в `Presenter` и без объявления интерфейсов.

Вспоминаем, что интерфейс - это не просто помощник в разрешении зависимостей. Интерфейс - это граница, это контракт. Да и про необходимость покрытия unit-тестами `Presenter` не забываем.

Интерфейс необходим. Объявляем в нем методы, к-е реализует `UseCase`. И классически располагаем там, где мы его используем. В нашем случае, в `Presenter`.

В случае Java это означает, что в `UseCase` будет зависеть от `Presenter` (`import Presenter` в `UseCase`). Так мы нарушаем основное правило чистой архитектуры!

Нарушать его нельзя. Поэтому располагаем интерфейс там где его реализуем - в `UseCase`. 
Выглядит странно. Но вспоминаем, что верхний уровень - это `Domain` (`UseCase` в том числе), это то, ради чего и создается приложение. Сложно представить ситуация замены реализации интерфейса `UseCase`. Да, логика может измениться, но тогда изменится и внешний мир (`Presenter`, `Repository`) или это изменение все-таки будет незаметно для внешнего мира (например, с помощью паттерна Стратегия). Т.о. возможность отделения интерфейса от реализации в данном случае не актуальна. Можем поместить интерфейс в `UseCase`.

Подобной дилемы размещения интерфейса не возникнет в языках с утиной типизацией, например, в Golang. Размещаем интерфейс в `Presenter` и никакого паразитного `import` в `UseCase` не появится.